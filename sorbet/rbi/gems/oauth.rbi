# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/oauth/all/oauth.rbi
#
# oauth-0.5.6

module OAuth
end
module OAuth::Client
end
module OAuth::Helper
  def _escape(string); end
  def escape(value); end
  def generate_key(size = nil); end
  def generate_nonce(size = nil); end
  def generate_timestamp; end
  def normalize(params); end
  def normalize_nested_query(value, prefix = nil); end
  def parse_header(header); end
  def stringify_keys(hash); end
  def unescape(value); end
  extend OAuth::Helper
end
module OAuth::RequestProxy
  def self.available_proxies; end
  def self.proxy(request, options = nil); end
end
class OAuth::RequestProxy::UnknownRequestType < Exception
end
class OAuth::RequestProxy::Base
  def consumer_key; end
  def header_params; end
  def initialize(request, options = nil); end
  def non_oauth_parameters; end
  def nonce; end
  def normalized_parameters; end
  def normalized_uri; end
  def oauth_callback; end
  def oauth_consumer_key; end
  def oauth_header(options = nil); end
  def oauth_nonce; end
  def oauth_parameters; end
  def oauth_signature; end
  def oauth_signature_method; end
  def oauth_timestamp; end
  def oauth_token; end
  def oauth_verifier; end
  def oauth_version; end
  def options; end
  def options=(arg0); end
  def parameters; end
  def parameters_for_signature; end
  def query_string_blank?; end
  def request; end
  def request=(arg0); end
  def self.proxies(klass); end
  def sign!(options = nil); end
  def sign(options = nil); end
  def signature; end
  def signature_and_unsigned_parameters; end
  def signature_base_string; end
  def signature_method; end
  def signed?; end
  def signed_uri(with_oauth = nil); end
  def timestamp; end
  def token; end
  def unsigned_parameters; end
  def unsigned_parameters=(arg0); end
  include OAuth::Helper
end
module OAuth::RequestProxy::Net
end
module OAuth::RequestProxy::Net::HTTP
end
class OAuth::RequestProxy::Net::HTTP::HTTPRequest < OAuth::RequestProxy::Base
  def all_parameters; end
  def auth_header_params; end
  def body; end
  def form_url_encoded?; end
  def method; end
  def parameters; end
  def post_params; end
  def query_params; end
  def query_string; end
  def uri; end
end
class Net::HTTPGenericRequest
  def oauth!(http, consumer = nil, token = nil, options = nil); end
  def oauth_body_hash_required?; end
  def oauth_full_request_uri(http, options); end
  def oauth_helper; end
  def oauth_helper_options(http, consumer, token, options); end
  def set_oauth_body; end
  def set_oauth_header; end
  def set_oauth_query_string; end
  def signature_base_string(http, consumer = nil, token = nil, options = nil); end
  include OAuth::Helper
end
class OAuth::Error < StandardError
end
class OAuth::Unauthorized < OAuth::Error
  def initialize(request = nil); end
  def request; end
  def to_s; end
end
class OAuth::Problem < OAuth::Unauthorized
  def initialize(problem, request = nil, params = nil); end
  def params; end
  def problem; end
  def to_s; end
end
class OAuth::Consumer
  def access_token_path; end
  def access_token_url; end
  def access_token_url?; end
  def authenticate_path; end
  def authenticate_url; end
  def authenticate_url?; end
  def authorize_path; end
  def authorize_url; end
  def authorize_url?; end
  def create_http(_url = nil); end
  def create_http_request(http_method, path, *arguments); end
  def create_signed_request(http_method, path, token = nil, request_options = nil, *arguments); end
  def debug_output; end
  def get_access_token(request_token, request_options = nil, *arguments, &block); end
  def get_request_token(request_options = nil, *arguments, &block); end
  def http; end
  def http=(arg0); end
  def http_method; end
  def initialize(consumer_key, consumer_secret, options = nil); end
  def key; end
  def key=(arg0); end
  def marshal_dump(*args); end
  def marshal_load(data); end
  def options; end
  def options=(arg0); end
  def proxy; end
  def request(http_method, path, token = nil, request_options = nil, *arguments); end
  def request_endpoint; end
  def request_token_path; end
  def request_token_url; end
  def request_token_url?; end
  def scheme; end
  def secret; end
  def secret=(arg0); end
  def sign!(request, token = nil, request_options = nil); end
  def signature_base_string(request, token = nil, request_options = nil); end
  def site; end
  def site=(arg0); end
  def token_request(http_method, path, token = nil, request_options = nil, *arguments); end
  def uri(custom_uri = nil); end
end
class OAuth::Token
  def initialize(token, secret); end
  def secret; end
  def secret=(arg0); end
  def to_query; end
  def token; end
  def token=(arg0); end
  include OAuth::Helper
end
class OAuth::ServerToken < OAuth::Token
  def initialize; end
end
class OAuth::ConsumerToken < OAuth::Token
  def consumer; end
  def consumer=(arg0); end
  def initialize(consumer, token = nil, secret = nil); end
  def params; end
  def params=(arg0); end
  def request(http_method, path, *arguments); end
  def response; end
  def self.from_hash(consumer, hash); end
  def sign!(request, options = nil); end
end
class OAuth::RequestToken < OAuth::ConsumerToken
  def authenticate_url(params = nil); end
  def authorize_url(params = nil); end
  def build_url(base_url, params); end
  def callback_confirmed?; end
  def get_access_token(options = nil, *arguments); end
end
class OAuth::AccessToken < OAuth::ConsumerToken
  def delete(path, headers = nil); end
  def get(path, headers = nil); end
  def head(path, headers = nil); end
  def patch(path, body = nil, headers = nil); end
  def post(path, body = nil, headers = nil); end
  def put(path, body = nil, headers = nil); end
  def request(http_method, path, *arguments); end
end
module OAuth::Signature
  def self.available_methods; end
  def self.body_hash(request, options = nil, &block); end
  def self.build(request, options = nil, &block); end
  def self.sign(request, options = nil, &block); end
  def self.signature_base_string(request, options = nil, &block); end
  def self.verify(request, options = nil, &block); end
end
class OAuth::Signature::UnknownSignatureMethod < Exception
end
class OAuth::Signature::Base
  def ==(cmp_signature); end
  def body_hash; end
  def consumer_key; end
  def consumer_secret; end
  def digest; end
  def initialize(request, options = nil, &block); end
  def nonce; end
  def options; end
  def options=(arg0); end
  def raise_instantiation_error; end
  def request; end
  def secret; end
  def self.implements(signature_method = nil); end
  def signature; end
  def signature_base_string; end
  def token; end
  def token_secret; end
  def verify; end
  include OAuth::Helper
end
module OAuth::Signature::HMAC
end
class OAuth::Signature::HMAC::SHA1 < OAuth::Signature::Base
  def body_hash; end
  def digest; end
end
class OAuth::Client::Helper
  def amend_user_agent_header(headers); end
  def hash_body; end
  def header; end
  def initialize(request, options = nil); end
  def nonce; end
  def oauth_parameters; end
  def options; end
  def parameters; end
  def parameters_with_oauth; end
  def signature(extra_options = nil); end
  def signature_base_string(extra_options = nil); end
  def timestamp; end
  def token_request?; end
  include OAuth::Helper
end
class OAuth::Signature::HMAC::SHA256 < OAuth::Signature::Base
  def body_hash; end
  def digest; end
end
module OAuth::Signature::RSA
end
class OAuth::Signature::RSA::SHA1 < OAuth::Signature::Base
  def ==(cmp_signature); end
  def body_hash; end
  def decode_public_key; end
  def digest; end
  def public_key; end
end
class OAuth::RequestProxy::MockRequest < OAuth::RequestProxy::Base
  def method; end
  def normalized_uri; end
  def parameters; end
  def uri; end
end
