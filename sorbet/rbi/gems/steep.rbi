# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/steep/all/steep.rbi
#
# steep-0.44.1

module Steep
  def self.log_error(exn, message: nil); end
  def self.log_output; end
  def self.log_output=(output); end
  def self.logger; end
  def self.measure(message, level: nil); end
  def self.measure2(message, level: nil); end
  def self.new_logger(output, prev_level); end
end
class Steep::InstanceMethodName < Struct
  def method_name; end
  def method_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
  def type_name; end
  def type_name=(_); end
end
class Steep::SingletonMethodName < Struct
  def method_name; end
  def method_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
  def type_name; end
  def type_name=(_); end
end
module Kernel
  def MethodName(string); end
end
module Steep::AST
end
module Steep::AST::Types
end
module Steep::AST::Types::Helper
end
module Steep::AST::Types::Helper::ChildrenLevel
  def level_of_children(children); end
end
module Steep::AST::Types::Helper::NoFreeVariables
  def free_variables; end
end
class Steep::AST::Types::Any
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Instance
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end
class Steep::AST::Types::Class
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end
class Steep::AST::Types::Union
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(types:, location: nil); end
  def level; end
  def location; end
  def self.build(types:, location: nil); end
  def subst(s); end
  def to_s; end
  def types; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
class Steep::AST::Types::Var
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(name:, location: nil); end
  def level; end
  def location; end
  def name; end
  def self.fresh(name); end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end
module Steep::AST::Types::Name
end
class Steep::AST::Types::Name::Base
  def initialize(name:, location: nil); end
  def level; end
  def location; end
  def name; end
  def subst(s); end
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Name::Applying < Steep::AST::Types::Name::Base
  def ==(other); end
  def args; end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(name:, args:, location: nil); end
  def level; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
class Steep::AST::Types::Name::Singleton < Steep::AST::Types::Name::Base
  def ==(other); end
  def eql?(other); end
  def hash; end
  def to_s; end
  def with_location(new_location); end
end
class Steep::AST::Types::Name::Instance < Steep::AST::Types::Name::Applying
  def to_module; end
end
class Steep::AST::Types::Name::Interface < Steep::AST::Types::Name::Applying
end
class Steep::AST::Types::Name::Alias < Steep::AST::Types::Name::Applying
end
class Steep::AST::Types::Self
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
end
class Steep::AST::Types::Intersection
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(types:, location: nil); end
  def level; end
  def location; end
  def self.build(types:, location: nil); end
  def subst(s); end
  def to_s; end
  def types; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
class Steep::AST::Types::Void
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Bot
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Top
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Nil
  def ==(other); end
  def back_type; end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Literal
  def ==(other); end
  def back_type; end
  def eql?(other); end
  def hash; end
  def initialize(value:, location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def value; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Boolean
  def ==(other); end
  def back_type; end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Tuple
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(types:, location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def types; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
class Steep::AST::Types::Proc
  def ==(other); end
  def back_type; end
  def block; end
  def block_required?; end
  def closed?; end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(type:, block:, location: nil); end
  def level; end
  def location; end
  def map_type(&block); end
  def one_arg?; end
  def subst(s); end
  def to_s; end
  def type; end
  def with_location(new_location); end
end
class Steep::AST::Types::Record
  def ==(other); end
  def elements; end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(elements:, location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
module Steep::AST::Types::Logic
end
class Steep::AST::Types::Logic::Base
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def location; end
  def subst(s); end
  def to_s; end
end
class Steep::AST::Types::Logic::Not < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::ReceiverIsNil < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::ReceiverIsNotNil < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::ReceiverIsArg < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::ArgIsReceiver < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::ArgEqualsReceiver < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::Env < Steep::AST::Types::Logic::Base
  def ==(other); end
  def eql?(other); end
  def falsy; end
  def hash; end
  def initialize(truthy:, falsy:, type:, location: nil); end
  def inspect; end
  def to_s; end
  def truthy; end
  def type; end
end
class Steep::AST::TypeParams
  def initialize(variables:, location: nil); end
  def location; end
  def variables; end
end
module Steep::AST::Annotation
end
class Steep::AST::Annotation::Named
  def ==(other); end
  def initialize(name:, type:, location: nil); end
  def location; end
  def name; end
  def type; end
end
class Steep::AST::Annotation::Typed
  def ==(other); end
  def annotation; end
  def initialize(type:, location: nil); end
  def location; end
  def type; end
end
class Steep::AST::Annotation::ReturnType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::BlockType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::SelfType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::InstanceType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::ModuleType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::BreakType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::MethodType < Steep::AST::Annotation::Named
end
class Steep::AST::Annotation::VarType < Steep::AST::Annotation::Named
end
class Steep::AST::Annotation::ConstType < Steep::AST::Annotation::Named
end
class Steep::AST::Annotation::IvarType < Steep::AST::Annotation::Named
end
class Steep::AST::Annotation::Implements
  def ==(other); end
  def initialize(name:, location: nil); end
  def location; end
  def name; end
end
class Steep::AST::Annotation::Implements::Module
  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def initialize(name:, args:); end
  def name; end
end
class Steep::AST::Annotation::Dynamic
  def ==(other); end
  def initialize(names:, location: nil); end
  def location; end
  def names; end
end
class Steep::AST::Annotation::Dynamic::Name
  def ==(other); end
  def initialize(name:, kind:, location: nil); end
  def instance_method?; end
  def kind; end
  def location; end
  def module_method?; end
  def name; end
end
class Steep::AST::Annotation::Collection
  def absolute_type(type); end
  def annotations; end
  def any?(&block); end
  def block_type; end
  def block_type_annotation; end
  def break_type; end
  def break_type_annotation; end
  def const_type_annotations; end
  def const_types; end
  def current_module; end
  def dynamic_annotations; end
  def factory; end
  def implement_module_annotation; end
  def include?(obj); end
  def initialize(annotations:, factory:, current_module:); end
  def instance_dynamics; end
  def instance_type; end
  def instance_type_annotation; end
  def ivar_type_annotations; end
  def ivar_types; end
  def lvar_types; end
  def merge_block_annotations(annotations); end
  def method_type(name); end
  def method_type_annotations; end
  def module_dynamics; end
  def module_type; end
  def module_type_annotation; end
  def return_type; end
  def return_type_annotation; end
  def self_type; end
  def self_type_annotation; end
  def size; end
  def var_type(lvar: nil, ivar: nil, const: nil); end
  def var_type_annotations; end
end
module Steep::AST::Builtin
  def self.any_type; end
  def self.bool_type; end
  def self.bottom_type; end
  def self.false_type; end
  def self.nil_type; end
  def self.optional(type); end
  def self.top_type; end
  def self.true_type; end
end
class Steep::AST::Builtin::Type
  def arity; end
  def initialize(module_name, arity: nil); end
  def instance_type(*args); end
  def instance_type?(type, args: nil); end
  def module_name; end
  def module_type; end
  def module_type?(type); end
end
class Steep::AST::Types::Factory
  def absolute_type(type, namespace:); end
  def absolute_type_name(type_name, namespace:); end
  def class_name?(type_name); end
  def deep_expand_alias(type, recursive: nil, &block); end
  def definition_builder; end
  def env; end
  def expand_alias(type); end
  def flatten_union(type, acc = nil); end
  def function_1(func); end
  def initialize(builder:); end
  def instance_type(type_name, args: nil, location: nil); end
  def interface(type, private:, self_type: nil); end
  def method_type(method_type, self_type:, method_decls:, subst2: nil); end
  def method_type_1(method_type, self_type:); end
  def module_name?(type_name); end
  def params(type); end
  def setup_primitives(method_name, method_def, method_type); end
  def type(type); end
  def type_1(type); end
  def type_cache; end
  def type_interface_cache; end
  def type_name_cache; end
  def type_name_resolver; end
  def unfold(type_name); end
  def unwrap_optional(type); end
end
class Steep::AST::Types::Factory::InterfaceCalculationError < StandardError
  def initialize(type:, message:); end
  def type; end
end
class RBS::Location
  def as_lsp_range; end
end
class Parser::Source::Range
  def as_lsp_range; end
end
module Steep::Interface
end
class Steep::Interface::Function
  def ==(other); end
  def closed?; end
  def each_type(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(params:, return_type:, location:); end
  def location; end
  def map_type(&block); end
  def params; end
  def return_type; end
  def subst(s); end
  def to_s; end
  def with(params: nil, return_type: nil); end
end
class Steep::Interface::Function::Params
  def &(other); end
  def +(other); end
  def ==(other); end
  def closed?; end
  def drop_first; end
  def each_extra_argument(args); end
  def each_extra_keyword(args); end
  def each_missing_argument(args); end
  def each_missing_keyword(args); end
  def each_type; end
  def empty?; end
  def eql?(other); end
  def extract_keywords(args); end
  def first_param; end
  def flat_keywords; end
  def flat_unnamed_params; end
  def free_variables; end
  def has_keywords?; end
  def has_positional?; end
  def hash; end
  def initialize(required:, optional:, rest:, required_keywords:, optional_keywords:, rest_keywords:); end
  def map_type(&block); end
  def optional; end
  def optional_keywords; end
  def required; end
  def required_keywords; end
  def rest; end
  def rest_keywords; end
  def self.empty; end
  def size; end
  def subst(s); end
  def to_s; end
  def update(required: nil, optional: nil, rest: nil, required_keywords: nil, optional_keywords: nil, rest_keywords: nil); end
  def with_first_param(param); end
  def without_keywords; end
  def |(other); end
end
class Steep::Interface::Function::Params::RequiredPositional < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Interface::Function::Params::OptionalPositional < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Interface::Function::Params::RestPositional < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Interface::Block
  def +(other); end
  def ==(other); end
  def closed?; end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(type:, optional:); end
  def map_type(&block); end
  def optional; end
  def optional?; end
  def required?; end
  def subst(s); end
  def to_optional; end
  def to_s; end
  def type; end
end
class Steep::Interface::MethodType
  def &(other); end
  def +(other); end
  def ==(other); end
  def block; end
  def each_type(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(type_params:, type:, block:, method_decls:); end
  def instantiate(s); end
  def map_type(&block); end
  def method_decls; end
  def subst(s); end
  def to_s; end
  def type; end
  def type_params; end
  def unify_overload(other); end
  def with(type_params: nil, type: nil, block: nil, method_decls: nil); end
  def |(other); end
end
class Steep::Interface::Substitution
  def [](key); end
  def add!(v, ty); end
  def dictionary; end
  def domain; end
  def empty?; end
  def except!(vars); end
  def except(vars); end
  def initialize(dictionary:, instance_type:, module_type:, self_type:); end
  def instance_type; end
  def key?(var); end
  def merge!(s, overwrite: nil); end
  def merge(s); end
  def module_type; end
  def self.build(vars, types = nil, instance_type: nil, module_type: nil, self_type: nil); end
  def self.empty; end
  def self_type; end
  def to_s; end
end
class Steep::Interface::Substitution::InvalidSubstitutionError < StandardError
  def initialize(vars_size:, types_size:); end
  def types_size; end
  def vars_size; end
end
class Steep::Interface::Interface
  def initialize(type:, private:); end
  def methods; end
  def private?; end
  def public?; end
  def type; end
end
class Steep::Interface::Interface::Entry
  def initialize(method_types:); end
  def method_types; end
  def to_s; end
end
module Steep::Subtyping
end
class Steep::Subtyping::Check
  def alias?(type); end
  def arg_type?(type); end
  def cache; end
  def cacheable?(relation); end
  def check(relation, constraints:, self_type:, instance_type:, class_type:, assumption: nil, trace: nil); end
  def check0(relation, self_type:, class_type:, instance_type:, assumption:, trace:, constraints:); end
  def check_block_given(name, sub_block, super_block, trace:, constraints:); end
  def check_block_params(name, sub_block, super_block, self_type:, instance_type:, class_type:, assumption:, trace:, constraints:); end
  def check_block_return(sub_block, super_block, self_type:, instance_type:, class_type:, assumption:, trace:, constraints:); end
  def check_generic_method_type(name, sub_type, super_type, self_type:, instance_type:, class_type:, assumption:, trace:, constraints:); end
  def check_interface(sub_interface, super_interface, self_type:, instance_type:, class_type:, assumption:, trace:, constraints:); end
  def check_method(name, sub_method, super_method, self_type:, instance_type:, class_type:, assumption:, trace:, constraints:); end
  def check_method_params(name, sub_params, super_params, self_type:, instance_type:, class_type:, assumption:, trace:, constraints:); end
  def check_method_type(name, sub_type, super_type, self_type:, instance_type:, class_type:, assumption:, trace:, constraints:); end
  def check_type_arg(relation, self_type:, instance_type:, class_type:, assumption:, trace:, constraints:); end
  def definition_for_type(type); end
  def each_ancestor(ancestors, &block); end
  def expand_alias(type, &block); end
  def extract_nominal_pairs(relation); end
  def factory; end
  def failure(error:, trace:); end
  def false_type?(type); end
  def initialize(factory:); end
  def instance_super_types(type_name, args:); end
  def match_method_type(name, sub_type, super_type, trace:); end
  def match_params(name, sub_params, super_params, trace:); end
  def same_type?(relation, assumption:); end
  def singleton_super_types(type_name); end
  def success(constraints:); end
  def success_all?(collection, &block); end
  def success_any?(collection, &block); end
  def true_type?(type); end
end
module Steep::Subtyping::Result
end
class Steep::Subtyping::Result::Base
  def else; end
  def failure?; end
  def then; end
end
class Steep::Subtyping::Result::Success < Steep::Subtyping::Result::Base
  def constraints; end
  def initialize(constraints:); end
  def success?; end
end
class Steep::Subtyping::Result::Failure < Steep::Subtyping::Result::Base
  def drop(n); end
  def error; end
  def initialize(error:, trace:); end
  def merge_trace(trace); end
  def success?; end
  def trace; end
end
class Steep::Subtyping::Result::Failure::MethodMissingError
  def initialize(name:); end
  def message; end
  def name; end
end
class Steep::Subtyping::Result::Failure::BlockMismatchError
  def initialize(name:); end
  def message; end
  def name; end
end
class Steep::Subtyping::Result::Failure::ParameterMismatchError
  def initialize(name:); end
  def message; end
  def name; end
end
class Steep::Subtyping::Result::Failure::UnknownPairError
  def initialize(relation:); end
  def message; end
  def relation; end
end
class Steep::Subtyping::Result::Failure::PolyMethodSubtyping
  def initialize(name:); end
  def message; end
  def name; end
end
class Steep::Subtyping::Relation
  def ==(other); end
  def eql?(other); end
  def flip; end
  def hash; end
  def initialize(sub_type:, super_type:); end
  def map; end
  def sub_type; end
  def super_type; end
  def to_s; end
end
class Steep::Subtyping::Trace
  def +(other); end
  def add(sup, sub); end
  def array; end
  def drop(n); end
  def each; end
  def empty?; end
  def initialize(array: nil); end
  def initialize_copy(source); end
  def interface(sub, sup, &block); end
  def method(name, sub, sup, &block); end
  def method_type(name, sub, sup, &block); end
  def push(*xs); end
  def size; end
  def type(sub, sup, &block); end
end
class Steep::Subtyping::Constraints
  def add(var, sub_type: nil, super_type: nil); end
  def add_var(*vars); end
  def dictionary; end
  def each; end
  def eliminate_variable(type, to:); end
  def empty?; end
  def has_constraint?(var); end
  def initialize(unknowns:); end
  def lower_bound(var); end
  def self.empty; end
  def solution(checker, variance:, variables:, self_type:, instance_type:, class_type:); end
  def to_s; end
  def unknown?(var); end
  def unknowns; end
  def upper_bound(var); end
  def vars; end
end
class Steep::Subtyping::Constraints::UnsatisfiedInvariantError < StandardError
  def constraints; end
  def initialize(reason:, constraints:); end
  def reason; end
end
class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::VariablesUnknownsNotDisjoint
  def initialize(vars:); end
  def message; end
  def vars; end
end
class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::VariablesFreeVariablesNotDisjoint
  def initialize(var: nil, lower_bound: nil, upper_bound: nil); end
  def lower_bound; end
  def message; end
  def upper_bound; end
  def var; end
end
class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::UnknownsFreeVariableNotDisjoint
  def initialize(var:, lower_bound:, upper_bound:); end
  def lower_bound; end
  def message; end
  def upper_bound; end
  def var; end
end
class Steep::Subtyping::Constraints::UnsatisfiableConstraint < StandardError
  def initialize(var:, sub_type:, super_type:, result:); end
  def result; end
  def sub_type; end
  def super_type; end
  def var; end
end
class Steep::Subtyping::VariableVariance
  def contravariant?(var); end
  def contravariants; end
  def covariant?(var); end
  def covariants; end
  def initialize(covariants:, contravariants:); end
  def invariant?(var); end
  def self.add_params(params, block:, covariants:, contravariants:); end
  def self.add_type(type, variance:, covariants:, contravariants:); end
  def self.from_method_type(method_type); end
end
class Steep::Subtyping::VariableOccurence
  def add_method_type(method_type); end
  def each_var(type, &block); end
  def initialize; end
  def params; end
  def returns; end
  def self.from_method_type(method_type); end
  def strictly_return?(var); end
end
module Steep::Diagnostic
end
module Steep::Diagnostic::Helper
  def error_name; end
  def full_message; end
end
module Steep::Diagnostic::Ruby
end
class Steep::Diagnostic::Ruby::Base
  def detail_lines; end
  def diagnostic_code; end
  def header_line; end
  def initialize(node:, location: nil); end
  def location; end
  def node; end
  include Steep::Diagnostic::Helper
end
module Steep::Diagnostic::Ruby::ResultPrinter
  def detail_lines; end
  def print_result_to(io, level: nil); end
  def trace_lines; end
end
class Steep::Diagnostic::Ruby::IncompatibleAssignment < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, lhs_type:, rhs_type:, result:); end
  def lhs_type; end
  def result; end
  def rhs_type; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::IncompatibleArguments < Steep::Diagnostic::Ruby::Base
  def detail_lines; end
  def header_line; end
  def initialize(node:, method_name:, receiver_type:, method_types:); end
  def method_name; end
  def method_types; end
  def node; end
  def receiver_type; end
end
class Steep::Diagnostic::Ruby::UnresolvedOverloading < Steep::Diagnostic::Ruby::Base
  def detail_lines; end
  def header_line; end
  def initialize(node:, receiver_type:, method_name:, method_types:); end
  def method_name; end
  def method_types; end
  def node; end
  def receiver_type; end
end
class Steep::Diagnostic::Ruby::ArgumentTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, receiver_type:, expected:, actual:, result:); end
  def node; end
  def receiver_type; end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::NoMethod < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, type:, method:); end
  def method; end
  def type; end
end
class Steep::Diagnostic::Ruby::ReturnTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::UnexpectedBlockGiven < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, method_type:); end
  def method_type; end
end
class Steep::Diagnostic::Ruby::RequiredBlockMissing < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, method_type:); end
  def method_type; end
end
class Steep::Diagnostic::Ruby::BlockTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::BlockBodyTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::BreakTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::UnexpectedJump < Steep::Diagnostic::Ruby::Base
  def header_line; end
end
class Steep::Diagnostic::Ruby::UnexpectedJumpValue < Steep::Diagnostic::Ruby::Base
  def header_line; end
end
class Steep::Diagnostic::Ruby::MethodArityMismatch < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, method_type:); end
  def method_type; end
end
class Steep::Diagnostic::Ruby::IncompatibleMethodTypeAnnotation < Steep::Diagnostic::Ruby::Base
  def annotation_method; end
  def initialize(node:, interface_method:, annotation_method:, result:); end
  def interface_method; end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::MethodReturnTypeAnnotationMismatch < Steep::Diagnostic::Ruby::Base
  def annotation_type; end
  def header_line; end
  def initialize(node:, method_type:, annotation_type:, result:); end
  def method_type; end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::MethodBodyTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::UnexpectedYield < Steep::Diagnostic::Ruby::Base
  def header_line; end
end
class Steep::Diagnostic::Ruby::UnexpectedSuper < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, method:); end
  def method; end
end
class Steep::Diagnostic::Ruby::MethodDefinitionMissing < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, module_name:, kind:, missing_method:); end
  def kind; end
  def missing_method; end
  def module_name; end
end
class Steep::Diagnostic::Ruby::UnexpectedDynamicMethod < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, module_name:, method_name:); end
  def method_name; end
  def module_name; end
end
class Steep::Diagnostic::Ruby::UnknownConstantAssigned < Steep::Diagnostic::Ruby::Base
  def context; end
  def header_line; end
  def initialize(node:, context:, name:); end
  def name; end
end
class Steep::Diagnostic::Ruby::FallbackAny < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:); end
end
class Steep::Diagnostic::Ruby::UnsatisfiableConstraint < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, method_type:, var:, sub_type:, super_type:, result:); end
  def method_type; end
  def result; end
  def sub_type; end
  def super_type; end
  def var; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::IncompatibleAnnotation < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, var_name:, result:, relation:); end
  def relation; end
  def result; end
  def var_name; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::IncompatibleTypeCase < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, var_name:, result:, relation:); end
  def relation; end
  def result; end
  def var_name; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::ElseOnExhaustiveCase < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, type:); end
  def type; end
end
class Steep::Diagnostic::Ruby::UnexpectedSplat < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, type:); end
  def type; end
end
class Steep::Diagnostic::Ruby::UnexpectedKeyword < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, unexpected_keywords:); end
  def unexpected_keywords; end
end
class Steep::Diagnostic::Ruby::MissingKeyword < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, missing_keywords:); end
  def missing_keywords; end
end
class Steep::Diagnostic::Ruby::UnsupportedSyntax < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, message: nil); end
  def message; end
end
class Steep::Diagnostic::Ruby::UnexpectedError < Steep::Diagnostic::Ruby::Base
  def error; end
  def header_line; end
  def initialize(node:, error:); end
  def message; end
end
class Steep::Diagnostic::Ruby::SyntaxError < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(message:, location:); end
  def message; end
end
module Steep::Diagnostic::Signature
  def self.from_rbs_error(error, factory:); end
end
class Steep::Diagnostic::Signature::Base
  def detail_lines; end
  def diagnostic_code; end
  def header_line; end
  def initialize(location:); end
  def location; end
  def path; end
  include Steep::Diagnostic::Helper
end
class Steep::Diagnostic::Signature::SyntaxError < Steep::Diagnostic::Signature::Base
  def exception; end
  def header_line; end
  def initialize(exception, location:); end
  def self.parser_syntax_error_message(exception); end
end
class Steep::Diagnostic::Signature::DuplicatedDeclaration < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(type_name:, location:); end
  def type_name; end
end
class Steep::Diagnostic::Signature::UnknownTypeName < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(name:, location:); end
  def name; end
end
class Steep::Diagnostic::Signature::InvalidTypeApplication < Steep::Diagnostic::Signature::Base
  def args; end
  def header_line; end
  def initialize(name:, args:, params:, location:); end
  def name; end
  def params; end
end
class Steep::Diagnostic::Signature::InvalidMethodOverload < Steep::Diagnostic::Signature::Base
  def class_name; end
  def header_line; end
  def initialize(class_name:, method_name:, location:); end
  def method_name; end
end
class Steep::Diagnostic::Signature::UnknownMethodAlias < Steep::Diagnostic::Signature::Base
  def class_name; end
  def header_line; end
  def initialize(class_name:, method_name:, location:); end
  def method_name; end
end
class Steep::Diagnostic::Signature::DuplicatedMethodDefinition < Steep::Diagnostic::Signature::Base
  def class_name; end
  def header_line; end
  def initialize(class_name:, method_name:, location:); end
  def method_name; end
end
class Steep::Diagnostic::Signature::RecursiveAlias < Steep::Diagnostic::Signature::Base
  def class_name; end
  def header_line; end
  def initialize(class_name:, names:, location:); end
  def location; end
  def names; end
end
class Steep::Diagnostic::Signature::RecursiveAncestor < Steep::Diagnostic::Signature::Base
  def ancestors; end
  def header_line; end
  def initialize(ancestors:, location:); end
end
class Steep::Diagnostic::Signature::SuperclassMismatch < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(name:, location:); end
  def name; end
end
class Steep::Diagnostic::Signature::GenericParameterMismatch < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(name:, location:); end
  def name; end
end
class Steep::Diagnostic::Signature::InvalidVarianceAnnotation < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(name:, param:, location:); end
  def name; end
  def param; end
end
class Steep::Diagnostic::Signature::ModuleSelfTypeError < Steep::Diagnostic::Signature::Base
  def ancestor; end
  def header_line; end
  def initialize(name:, ancestor:, relation:, location:); end
  def name; end
  def relation; end
end
class Steep::Diagnostic::Signature::InstanceVariableTypeError < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(name:, location:, var_type:, parent_type:); end
  def name; end
  def parent_type; end
  def var_type; end
  def variable; end
end
class Steep::Diagnostic::Signature::UnexpectedError < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(message:, location:); end
  def message; end
end
class Steep::Diagnostic::LSPFormatter
  def format(diagnostic); end
end
module Steep::Signature
end
class Steep::Signature::Validator
  def ancestor_to_type(ancestor); end
  def builder; end
  def checker; end
  def each_error(&block); end
  def env; end
  def factory; end
  def has_error?; end
  def initialize(checker:); end
  def mixin_constraints(definition, mixin_ancestors, immediate_self_types:); end
  def no_error?; end
  def rescue_validation_errors(type_name = nil); end
  def type_name_resolver; end
  def validate; end
  def validate_alias; end
  def validate_const; end
  def validate_decl; end
  def validate_global; end
  def validate_one_alias(name); end
  def validate_one_class(name); end
  def validate_one_constant(name, entry); end
  def validate_one_global(name, entry); end
  def validate_one_interface(name); end
  def validate_type(type); end
  def validator; end
end
class Steep::Source
  def annotations(block:, factory:, current_module:); end
  def compact_siblings(node); end
  def each_annotation(&block); end
  def find_nodes(line:, column:, node: nil, position: nil, parents: nil); end
  def initialize(path:, node:, mapping:); end
  def mapping; end
  def node; end
  def path; end
  def self.construct_mapping(node:, annotations:, mapping:, line_range: nil); end
  def self.delete_defs(node, allow_list); end
  def self.each_child_node(node); end
  def self.map_child_nodes(node); end
  def self.parse(source_code, path:, factory:); end
  def self.parser; end
  def without_unrelated_defs(line:, column:); end
end
class Steep::Source::LocatedAnnotation
  def ==(other); end
  def annotation; end
  def initialize(line:, source:, annotation:); end
  def line; end
  def source; end
end
class Steep::Source::Builder < Parser::Builders::Default
  def string_value(token); end
end
class Steep::AnnotationParser
  def factory; end
  def initialize(factory:); end
  def keyword_and_type(keyword); end
  def keyword_subject_type(keyword, name); end
  def parse(src, location:); end
  def parse_type(string); end
end
class Steep::AnnotationParser::SyntaxError < StandardError
  def initialize(source:, location:, exn: nil); end
  def location; end
  def source; end
end
class Steep::Typing
  def add_call(node, call); end
  def add_context(range, context:); end
  def add_context_for_body(node, context:); end
  def add_context_for_node(node, context:); end
  def add_error(error); end
  def add_typing(node, type, _context); end
  def block_range(node); end
  def call_of(node:); end
  def context_at(line:, column:); end
  def contexts; end
  def dump(io); end
  def each_typing(&block); end
  def errors; end
  def has_type?(node); end
  def initialize(source:, root_context:, parent: nil, parent_last_update: nil, contexts: nil, source_index: nil); end
  def last_update; end
  def method_calls; end
  def new_child(range); end
  def parent; end
  def parent_last_update; end
  def root_context; end
  def save!; end
  def self.summary(node); end
  def should_update; end
  def source; end
  def source_index; end
  def type_of(node:); end
  def typing; end
end
class Steep::Typing::UnknownNodeError < StandardError
  def initialize(op, node:); end
  def node; end
  def op; end
end
module Steep::ModuleHelper
  def module_name_from_node(node); end
  def namespace_from_node(node); end
end
class Steep::TypeConstruction
  def absolute_name(module_name); end
  def absolute_type(type); end
  def add_call(call); end
  def add_typing(node, type:, constr: nil); end
  def annotations; end
  def block_context; end
  def break_context; end
  def calculate_interface(type, private:, self_type: nil); end
  def check(node, type, constraints: nil); end
  def check_keyword_arg(receiver_type:, node:, method_type:, constraints:); end
  def check_relation(sub_type:, super_type:, constraints: nil); end
  def checker; end
  def context; end
  def current_namespace; end
  def deep_expand_alias(type, &block); end
  def default_module_context(implement_module_name, const_env:, current_namespace:); end
  def each_child_node(node); end
  def expand_alias(type, &block); end
  def expand_self(type); end
  def fallback_any_rec(node); end
  def fallback_to_any(node); end
  def flatten_array_elements(type); end
  def flatten_const_name(node); end
  def flatten_union(type); end
  def for_block(block_params:, block_param_hint:, block_type_hint:, block_annotations:, node_type_hint:); end
  def for_branch(node, truthy_vars: nil, type_case_override: nil, break_context: nil); end
  def for_class(node); end
  def for_module(node); end
  def for_new_method(method_name, node, args:, self_type:, definition:); end
  def for_sclass(node, type); end
  def implement_module(module_name:, annotations:, super_name: nil); end
  def initialize(checker:, source:, annotations:, typing:, context:); end
  def ivasgn(node, type); end
  def lvasgn(node, type); end
  def masgn_lhs?(lhs); end
  def method_context; end
  def module_context; end
  def namespace_module?(node); end
  def nested_namespace_for_module(module_name); end
  def partition_flatten_types(type, &block); end
  def select_flatten_types(type, &block); end
  def select_super_type(sub_type, super_type); end
  def self.parameter_types(nodes, type); end
  def self.valid_parameter_env?(env, nodes, params); end
  def self.value_variables(node); end
  def self_class?(node); end
  def self_type; end
  def source; end
  def synthesize(node, hint: nil, condition: nil); end
  def synthesize_block(node:, block_type_hint:, block_body:); end
  def synthesize_children(node, skips: nil); end
  def test_literal_type(literal, hint); end
  def to_instance_type(type, args: nil); end
  def try_array_type(node, hint); end
  def try_hash_type(node, hint); end
  def try_method_type(node, receiver_type:, method_name:, method_type:, args:, arg_pairs:, block_params:, block_body:, topdown_hint:); end
  def try_tuple_type(node, hint); end
  def type_any_rec(node); end
  def type_block_without_hint(node:, block_annotations:, block_params:, block_body:, &block); end
  def type_env; end
  def type_ivasgn(name, rhs, node); end
  def type_lambda(node, block_params:, block_body:, type_hint:); end
  def type_masgn(node); end
  def type_method_call(node, method_name:, receiver_type:, method:, args:, block_params:, block_body:, topdown_hint:); end
  def type_send(node, send_node:, block_params:, block_body:, unwrap: nil); end
  def type_send_interface(node, interface:, receiver:, receiver_type:, method_name:, arguments:, block_params:, block_body:); end
  def typing; end
  def union_type(*types); end
  def unwrap(type); end
  def update_context; end
  def update_lvar_env; end
  def validate_method_definitions(node, module_name); end
  def with(annotations: nil, context: nil, typing: nil); end
  def with_new_typing(typing); end
  def with_updated_context(lvar_env: nil); end
  include Steep::ModuleHelper
end
class Steep::TypeConstruction::Pair
  def +(other); end
  def constr; end
  def context; end
  def initialize(type:, constr:); end
  def to_ary; end
  def type; end
  def with(type: nil, constr: nil); end
end
module Steep::TypeInference
end
class Steep::TypeInference::Context
  def block_context; end
  def break_context; end
  def call_context; end
  def initialize(method_context:, block_context:, break_context:, module_context:, self_type:, type_env:, lvar_env:, call_context:); end
  def lvar_env; end
  def method_context; end
  def module_context; end
  def self_type; end
  def type_env; end
  def with(method_context: nil, block_context: nil, break_context: nil, module_context: nil, self_type: nil, type_env: nil, lvar_env: nil, call_context: nil); end
end
class Steep::TypeInference::Context::MethodContext
  def block_type; end
  def constructor; end
  def initialize(name:, method:, method_type:, return_type:, constructor:, super_method:); end
  def method; end
  def method_type; end
  def name; end
  def return_type; end
  def super_method; end
end
class Steep::TypeInference::Context::BlockContext
  def body_type; end
  def initialize(body_type:); end
end
class Steep::TypeInference::Context::BreakContext
  def break_type; end
  def initialize(break_type:, next_type:); end
  def next_type; end
end
class Steep::TypeInference::Context::ModuleContext
  def class_name; end
  def class_variables; end
  def const_context; end
  def const_env; end
  def current_namespace; end
  def defined_instance_methods; end
  def defined_module_methods; end
  def implement_name; end
  def initialize(instance_type:, module_type:, implement_name:, current_namespace:, const_env:, class_name:, instance_definition: nil, module_definition: nil); end
  def instance_definition; end
  def instance_type; end
  def module_definition; end
  def module_type; end
  def namespaces; end
  def update(instance_type: nil, module_type: nil, implement_name: nil, current_namespace: nil, const_env: nil, class_name: nil, instance_definition: nil, module_definition: nil); end
end
class Steep::TypeInference::ContextArray
  def [](index); end
  def at(line:, column:); end
  def buffer; end
  def context_at(index, entry: nil); end
  def each_entry; end
  def initialize(buffer:, context:, range: nil); end
  def insert_context(range, context:, entry: nil); end
  def merge(subtree); end
  def range; end
  def root; end
  def self.from_source(source:, range: nil, context: nil); end
end
class Steep::TypeInference::ContextArray::Entry
  def context; end
  def initialize(range:, context:); end
  def range; end
  def sub_entries; end
end
class Steep::TypeInference::SendArgs
  def add_pair(pairs, pair); end
  def args; end
  def block_pass_arg; end
  def drop_first; end
  def drop_last; end
  def each_keyword_arg; end
  def group_pairs(pairs); end
  def initialize(args:, block_pass_arg:); end
  def kwsplat_nodes; end
  def self.from_nodes(nodes); end
  def zip0(params, block_type); end
  def zips(params, block_type); end
end
class Steep::TypeInference::BlockParams
  def each(&block); end
  def expandable?; end
  def expandable_params?(params_type); end
  def initialize(leading_params:, optional_params:, rest_param:, trailing_params:); end
  def leading_params; end
  def optional_params; end
  def params; end
  def params_type(hint: nil); end
  def params_type0(hint:); end
  def rest_param; end
  def self.from_node(node, annotations:); end
  def trailing_params; end
  def zip(params_type); end
end
class Steep::TypeInference::BlockParams::Param
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(var:, type:, value:, node:); end
  def node; end
  def type; end
  def value; end
  def var; end
end
class Steep::TypeInference::ConstantEnv
  def cache; end
  def context; end
  def factory; end
  def initialize(factory:, context:); end
  def lookup(name); end
  def lookup_constant(name); end
  def table; end
end
class Steep::TypeInference::TypeEnv
  def assert_annotation(name, annotated_type:, original_type:, self_type:, instance_type:, class_type:); end
  def assert_assign(var_type:, lhs_type:, self_type:, instance_type:, class_type:); end
  def assign(type:, self_type:, instance_type:, class_type:, const: nil, gvar: nil, ivar: nil, &block); end
  def const_env; end
  def const_types; end
  def get(const: nil, gvar: nil, ivar: nil); end
  def gvar_types; end
  def initialize(subtyping:, const_env:); end
  def initialize_copy(other); end
  def ivar_types; end
  def lookup_dictionary(ivar:, gvar:); end
  def merge!(original_env:, override_env:, self_type:, instance_type:, class_type:, &block); end
  def self.build(annotations:, signatures:, subtyping:, const_env:); end
  def set(type:, const: nil, gvar: nil, ivar: nil); end
  def subtyping; end
  def with_annotations(self_type:, instance_type:, class_type:, ivar_types: nil, const_types: nil, gvar_types: nil, &block); end
end
class Steep::TypeInference::LocalVariableTypeEnv
  def [](var); end
  def annotate(collection); end
  def assign!(var, node:, type:); end
  def assign(var, node:, type:); end
  def assigned_types; end
  def class_type; end
  def declared_types; end
  def each; end
  def entry(var); end
  def except(variables); end
  def initialize(subtyping:, declared_types:, assigned_types:, self_type:, instance_type:, class_type:); end
  def instance_type; end
  def join(*envs); end
  def join_entry(e1, e2); end
  def pin_assignments; end
  def self.empty(subtyping:, self_type:, instance_type:, class_type:); end
  def self_type; end
  def subst(s); end
  def subtyping; end
  def to_s; end
  def update(declared_types: nil, assigned_types: nil, self_type: nil, instance_type: nil, class_type: nil); end
  def vars; end
end
class Steep::TypeInference::LocalVariableTypeEnv::Entry
  def +(other); end
  def ==(other); end
  def annotations; end
  def initialize(type:, annotations: nil, nodes: nil); end
  def nodes; end
  def optional; end
  def type; end
  def update(type: nil, annotations: nil, nodes: nil); end
end
class Steep::TypeInference::Logic
  def environments(truthy_vars:, falsey_vars:, lvar_env:); end
  def initialize(subtyping:); end
  def nodes(node:); end
  def partition_union(type); end
  def subtyping; end
end
class Steep::TypeInference::Logic::Result
  def +(other); end
  def initialize(nodes = nil); end
  def merge(nodes); end
  def nodes; end
  def vars; end
end
class Steep::TypeInference::LogicTypeInterpreter
  def decompose_value(node); end
  def eval(env:, type:, node:); end
  def factory; end
  def guess_type_from_method(node); end
  def initialize(subtyping:, typing:); end
  def literal_var_type_case_select(value_node, arg_type); end
  def subtyping; end
  def type_case_select(type, klass); end
  def type_case_select0(type, klass); end
  def typing; end
end
class Steep::TypeInference::MethodCall
end
class Steep::TypeInference::MethodCall::MethodDecl
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(method_name:, method_def:); end
  def method_def; end
  def method_name; end
  def method_type; end
end
class Steep::TypeInference::MethodCall::MethodContext < Struct
  def method_name; end
  def method_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
end
class Steep::TypeInference::MethodCall::ModuleContext < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
  def type_name; end
  def type_name=(_); end
end
class Steep::TypeInference::MethodCall::TopLevelContext
  def to_s; end
end
class Steep::TypeInference::MethodCall::UnknownContext
  def to_s; end
end
class Steep::TypeInference::MethodCall::Base
  def context; end
  def initialize(node:, context:, method_name:, receiver_type:, return_type:); end
  def method_name; end
  def node; end
  def receiver_type; end
  def return_type; end
  def with_return_type(new_type); end
end
class Steep::TypeInference::MethodCall::Typed < Steep::TypeInference::MethodCall::Base
  def actual_method_type; end
  def initialize(node:, context:, method_name:, receiver_type:, actual_method_type:, method_decls:, return_type: nil); end
  def method_decls; end
end
class Steep::TypeInference::MethodCall::Untyped < Steep::TypeInference::MethodCall::Base
  def initialize(node:, context:, method_name:); end
end
class Steep::TypeInference::MethodCall::NoMethodError < Steep::TypeInference::MethodCall::Base
  def error; end
  def initialize(node:, context:, method_name:, receiver_type:, error:); end
end
class Steep::TypeInference::MethodCall::Error < Steep::TypeInference::MethodCall::Base
  def errors; end
  def initialize(node:, context:, method_name:, receiver_type:, errors:, method_decls: nil, return_type: nil); end
  def method_decls; end
end
class Steep::AST::Types::Masked
  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(type:, mask:, location:); end
  def location; end
  def mask; end
  def sub(s); end
  def to_json(*a); end
  def to_s(level = nil); end
  def type; end
end
module Steep::Index
end
class Steep::Index::RBSIndex
  def add_constant_declaration(const_name, decl); end
  def add_global_declaration(global_name, decl); end
  def add_method_declaration(method_name, member); end
  def add_type_declaration(type_name, declaration); end
  def add_type_reference(type_name, ref); end
  def const_index; end
  def each_declaration(type_name: nil, method_name: nil, const_name: nil, global_name: nil, &block); end
  def each_entry(&block); end
  def each_reference(type_name: nil, &block); end
  def entry(type_name: nil, method_name: nil, const_name: nil, global_name: nil); end
  def global_index; end
  def initialize; end
  def method_index; end
  def type_index; end
end
class Steep::Index::RBSIndex::TypeEntry
  def add_declaration(decl); end
  def add_reference(ref); end
  def declarations; end
  def initialize(type_name:); end
  def references; end
  def type_name; end
end
class Steep::Index::RBSIndex::MethodEntry
  def add_declaration(decl); end
  def declarations; end
  def initialize(method_name:); end
  def method_name; end
  def references; end
end
class Steep::Index::RBSIndex::ConstantEntry
  def add_declaration(decl); end
  def const_name; end
  def declarations; end
  def initialize(const_name:); end
end
class Steep::Index::RBSIndex::GlobalEntry
  def add_declaration(decl); end
  def declarations; end
  def global_name; end
  def initialize(global_name:); end
end
class Steep::Index::RBSIndex::Builder
  def env(env); end
  def index; end
  def initialize(index:); end
  def member(type_name, member); end
  def type_reference(type, from:); end
end
class Steep::Index::SignatureSymbolProvider
  def assigned?(path); end
  def assignment; end
  def indexes; end
  def initialize(project:, assignment:); end
  def project; end
  def query_symbol(query); end
  def self.test_const_name(query, type_name); end
  def self.test_global_name(query, type_name); end
  def self.test_method_name(query, method_name); end
  def self.test_type_name(query, type_name); end
end
class Steep::Index::SignatureSymbolProvider::SymbolInformation < Struct
  def container_name; end
  def container_name=(_); end
  def kind; end
  def kind=(_); end
  def location; end
  def location=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Index::SourceIndex
  def add_definition(definition:, constant: nil, method: nil); end
  def add_reference(ref:, constant: nil, method: nil); end
  def constant_index; end
  def count; end
  def entry(constant: nil, method: nil); end
  def initialize(source:, parent: nil); end
  def merge!(child); end
  def method_index; end
  def new_child; end
  def parent; end
  def parent_count; end
  def source; end
end
class Steep::Index::SourceIndex::ConstantEntry
  def add_definition(node); end
  def add_reference(node); end
  def definitions; end
  def initialize(name:); end
  def merge!(other); end
  def name; end
  def references; end
end
class Steep::Index::SourceIndex::MethodEntry
  def add_definition(node); end
  def add_reference(node); end
  def definitions; end
  def initialize(name:); end
  def merge!(other); end
  def name; end
  def references; end
end
module Steep::Server
end
module Steep::Server::ChangeBuffer
  def buffered_changes; end
  def collect_changes(request); end
  def load_files(project:, commandline_args:); end
  def mutex; end
  def pop_buffer; end
  def push_buffer; end
end
class Steep::Server::BaseWorker
  def handle_job(job); end
  def handle_request(request); end
  def initialize(project:, reader:, writer:); end
  def project; end
  def queue; end
  def reader; end
  def run; end
  def skip_job?; end
  def skip_jobs_after_shutdown!(flag = nil); end
  def skip_jobs_after_shutdown?; end
  def writer; end
end
class Steep::Server::BaseWorker::ShutdownJob < Struct
  def id; end
  def id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::WorkerProcess
  def <<(message); end
  def index; end
  def initialize(reader:, writer:, stderr:, wait_thread:, name:, index: nil); end
  def kill; end
  def name; end
  def read(&block); end
  def reader; end
  def self.spawn_typecheck_workers(steepfile:, args:, count: nil, delay_shutdown: nil); end
  def self.spawn_worker(type, name:, steepfile:, options: nil, delay_shutdown: nil, index: nil); end
  def stderr; end
  def wait_thread; end
  def writer; end
end
class Steep::Server::InteractionWorker < Steep::Server::BaseWorker
  def format_completion_item(item); end
  def format_hover(content); end
  def handle_job(job); end
  def handle_request(request); end
  def initialize(project:, reader:, writer:, queue: nil); end
  def method_type_to_snippet(method_type); end
  def params_to_snippet(fun); end
  def process_completion(job); end
  def process_hover(job); end
  def service; end
  include Steep::Server::ChangeBuffer
end
class Steep::Server::InteractionWorker::ApplyChangeJob
end
class Steep::Server::InteractionWorker::HoverJob < Struct
  def column; end
  def column=(_); end
  def id; end
  def id=(_); end
  def line; end
  def line=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::InteractionWorker::CompletionJob < Struct
  def column; end
  def column=(_); end
  def id; end
  def id=(_); end
  def line; end
  def line=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def trigger; end
  def trigger=(_); end
end
class Steep::Server::TypeCheckWorker < Steep::Server::BaseWorker
  def assignment; end
  def commandline_args; end
  def current_type_check_guid; end
  def enqueue_typecheck_jobs(params); end
  def goto(job); end
  def handle_job(job); end
  def handle_request(request); end
  def initialize(project:, reader:, writer:, assignment:, commandline_args:); end
  def project; end
  def service; end
  def stats_result; end
  def typecheck_progress(guid:, path:); end
  def workspace_symbol_result(query); end
  include Steep::Server::ChangeBuffer
end
class Steep::Server::TypeCheckWorker::WorkspaceSymbolJob < Struct
  def id; end
  def id=(_); end
  def query; end
  def query=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::StatsJob < Struct
  def id; end
  def id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::StartTypeCheckJob < Struct
  def changes; end
  def changes=(_); end
  def guid; end
  def guid=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::TypeCheckCodeJob < Struct
  def guid; end
  def guid=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::ValidateAppSignatureJob < Struct
  def guid; end
  def guid=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::ValidateLibrarySignatureJob < Struct
  def guid; end
  def guid=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::GotoJob < Struct
  def definition?; end
  def id; end
  def id=(_); end
  def implementation?; end
  def kind; end
  def kind=(_); end
  def params; end
  def params=(_); end
  def self.[](*arg0); end
  def self.definition(id:, params:); end
  def self.implementation(id:, params:); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::Master
  def broadcast_notification(message); end
  def commandline_args; end
  def controller; end
  def current_type_check_request; end
  def each_worker(&block); end
  def fresh_request_id; end
  def group_request; end
  def initialize(project:, reader:, writer:, interaction_worker:, typecheck_workers:, queue: nil); end
  def initialize_params; end
  def interaction_worker; end
  def job_queue; end
  def kill; end
  def on_type_check_update(guid:, path:); end
  def pathname(uri); end
  def process_message_from_client(message); end
  def process_message_from_worker(message, worker:); end
  def project; end
  def reader; end
  def result_controller; end
  def send_notification(message, worker:); end
  def send_request(method:, worker:, id: nil, params: nil, &block); end
  def start; end
  def start_type_check(request, last_request:, start_progress:); end
  def steepfile; end
  def typecheck_automatically; end
  def typecheck_automatically=(arg0); end
  def typecheck_workers; end
  def work_done_progress_supported?; end
  def writer; end
end
class Steep::Server::Master::TypeCheckRequest
  def all_paths; end
  def as_json(assignment:); end
  def checked(path); end
  def checked_paths; end
  def checking_path?(path); end
  def code_paths; end
  def finished?; end
  def guid; end
  def initialize(guid:); end
  def library_paths; end
  def percentage; end
  def priority_paths; end
  def signature_paths; end
  def total; end
  def unchecked_code_paths; end
  def unchecked_library_paths; end
  def unchecked_paths; end
  def unchecked_signature_paths; end
  def uri(path); end
end
class Steep::Server::Master::TypeCheckController
  def changed_paths; end
  def initialize(project:); end
  def load(command_line_args:); end
  def make_request(guid: nil, last_request: nil, include_unchanged: nil); end
  def priority_paths; end
  def project; end
  def push_changes(path); end
  def target_paths; end
  def update_priority(open: nil, close: nil); end
end
class Steep::Server::Master::TypeCheckController::TargetPaths
  def <<(path); end
  def add(path); end
  def all_paths; end
  def code_path?(path); end
  def code_paths; end
  def initialize(project:, target:); end
  def library_path?(path); end
  def library_paths; end
  def project; end
  def signature_path?(path); end
  def signature_paths; end
  def target; end
end
class Steep::Server::Master::ResultHandler
  def completed?; end
  def completion_handler; end
  def initialize(request:); end
  def on_completion(&block); end
  def process_response(message); end
  def request; end
  def response; end
  def result; end
end
class Steep::Server::Master::GroupHandler
  def <<(handler); end
  def completed?; end
  def completion_handler; end
  def handlers; end
  def initialize; end
  def on_completion(&block); end
  def process_response(message); end
  def request; end
end
class Steep::Server::Master::ResultController
  def <<(handler); end
  def handlers; end
  def initialize; end
  def process_response(message); end
  def request_group; end
end
class Steep::Server::Master::ReceiveMessageJob < Struct
  def message; end
  def message=(_); end
  def response?; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def source; end
  def source=(_); end
end
class Steep::Server::Master::SendMessageJob < Struct
  def dest; end
  def dest=(_); end
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def self.to_client(message:); end
  def self.to_worker(worker, message:); end
end
module Steep::Services
end
class Steep::Services::ContentChange
  def ==(other); end
  def apply_to(text); end
  def eql?(other); end
  def hash; end
  def initialize(text:, range: nil); end
  def range; end
  def self.string(string); end
  def text; end
end
class Steep::Services::ContentChange::Position
  def ==(other); end
  def column; end
  def eql?(other); end
  def hash; end
  def initialize(line:, column:); end
  def line; end
end
class Steep::Services::PathAssignment
  def ===(path); end
  def =~(path); end
  def cache; end
  def index; end
  def initialize(index:, max_index:); end
  def max_index; end
  def self.all; end
  def self.index_for(path:, max_index:); end
end
class Steep::Services::SignatureService
  def add_descendants(graph:, names:, set:); end
  def add_nested_decls(env:, names:, set:); end
  def apply_changes(files, changes); end
  def const_decls(paths:, env:); end
  def current_subtyping; end
  def each_rbs_path(&block); end
  def env_rbs_paths; end
  def files; end
  def global_decls(paths:, env: nil); end
  def initialize(env:); end
  def latest_builder; end
  def latest_env; end
  def latest_rbs_index; end
  def pending_changed_paths; end
  def rescue_rbs_error(errors); end
  def self.load_from(loader); end
  def status; end
  def type_name_from_decl(decl, set:); end
  def type_names(paths:, env:); end
  def update(changes); end
  def update_builder(ancestor_builder:, paths:); end
  def update_env(updated_files, paths:); end
end
class Steep::Services::SignatureService::SyntaxErrorStatus
  def changed_paths; end
  def diagnostics; end
  def files; end
  def initialize(files:, changed_paths:, diagnostics:, last_builder:); end
  def last_builder; end
  def rbs_index; end
end
class Steep::Services::SignatureService::AncestorErrorStatus
  def changed_paths; end
  def diagnostics; end
  def files; end
  def initialize(files:, changed_paths:, diagnostics:, last_builder:); end
  def last_builder; end
  def rbs_index; end
end
class Steep::Services::SignatureService::LoadedStatus
  def builder; end
  def files; end
  def initialize(files:, builder:); end
  def rbs_index; end
  def subtyping; end
end
class Steep::Services::SignatureService::FileStatus < Struct
  def content; end
  def content=(_); end
  def decls; end
  def decls=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::TypeCheckService
  def app_signature_file?(path); end
  def diagnostics; end
  def each_diagnostics(&block); end
  def has_diagnostics?; end
  def initialize(project:); end
  def lib_signature_file?(path); end
  def project; end
  def self.type_check(source:, subtyping:); end
  def signature_diagnostics; end
  def signature_file?(path); end
  def signature_services; end
  def signature_validation_diagnostics; end
  def source_file?(path); end
  def source_files; end
  def type_check_file(target:, subtyping:, path:, text:); end
  def typecheck_source(path:, target: nil, &block); end
  def update(changes:); end
  def update_and_check(changes:, assignment:, &block); end
  def update_signature(changes:, requests:); end
  def update_sources(changes:, requests:); end
  def validate_signature(path:, &block); end
end
class Steep::Services::TypeCheckService::SourceFile
  def content; end
  def diagnostics; end
  def errors; end
  def initialize(path:, node:, content:, typing:, errors:); end
  def node; end
  def path; end
  def self.no_data(path:, content:); end
  def self.with_syntax_error(path:, content:, error:); end
  def self.with_typing(path:, content:, typing:, node:); end
  def target; end
  def typing; end
  def update_content(content); end
end
class Steep::Services::TypeCheckService::TargetRequest
  def ==(other); end
  def empty?; end
  def eql?(other); end
  def hash; end
  def initialize(target:); end
  def signature_updated!(value = nil); end
  def signature_updated?; end
  def source_paths; end
  def target; end
end
class Steep::Services::HoverContent
  def content_for(path:, line:, column:); end
  def initialize(service:); end
  def method_definition_for(factory, type_name, singleton_method: nil, instance_method: nil); end
  def project; end
  def service; end
  def typecheck(target, path:, content:, line:, column:); end
end
class Steep::Services::HoverContent::TypeContent < Struct
  def location; end
  def location=(_); end
  def node; end
  def node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::HoverContent::VariableContent < Struct
  def location; end
  def location=(_); end
  def name; end
  def name=(_); end
  def node; end
  def node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::HoverContent::MethodCallContent < Struct
  def definition; end
  def definition=(_); end
  def location; end
  def location=(_); end
  def method_name; end
  def method_name=(_); end
  def node; end
  def node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::HoverContent::DefinitionContent < Struct
  def comment_string; end
  def definition; end
  def definition=(_); end
  def location; end
  def location=(_); end
  def method_name; end
  def method_name=(_); end
  def method_type; end
  def method_type=(_); end
  def node; end
  def node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::HoverContent::InstanceMethodName < Struct
  def class_name; end
  def class_name=(_); end
  def method_name; end
  def method_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::HoverContent::SingletonMethodName < Struct
  def class_name; end
  def class_name=(_); end
  def method_name; end
  def method_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::CompletionProvider
  def at_end?(pos, of:); end
  def disallowed_method?(name); end
  def index_for(string, line:, column:); end
  def initialize(source_text:, path:, subtyping:); end
  def instance_variable_items_for_context(context, position:, prefix:, items:); end
  def items_for_atmark(position:); end
  def items_for_dot(position:); end
  def items_for_trigger(position:); end
  def local_variable_items_for_context(context, position:, prefix:, items:); end
  def method_items_for_receiver_type(type, include_private:, prefix:, position:, items:); end
  def modified_text; end
  def path; end
  def range_for(position, prefix: nil); end
  def range_from_loc(loc); end
  def run(line:, column:); end
  def source; end
  def source_text; end
  def subtyping; end
  def type_check!(text, line:, column:); end
  def typing; end
  def word_name?(name); end
end
class Steep::Services::CompletionProvider::Position < Struct
  def -(size); end
  def column; end
  def column=(_); end
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::CompletionProvider::Range < Struct
  def end; end
  def end=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def start; end
  def start=(_); end
end
class Steep::Services::CompletionProvider::InstanceVariableItem < Struct
  def identifier; end
  def identifier=(_); end
  def range; end
  def range=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::CompletionProvider::LocalVariableItem < Struct
  def identifier; end
  def identifier=(_); end
  def range; end
  def range=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::CompletionProvider::MethodNameItem < Struct
  def comment; end
  def identifier; end
  def identifier=(_); end
  def inherited?; end
  def method_decls; end
  def method_decls=(_); end
  def method_type; end
  def method_type=(_); end
  def range; end
  def range=(_); end
  def receiver_type; end
  def receiver_type=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::StatsCalculator
  def calc_stats(target, file:); end
  def initialize(service:); end
  def project; end
  def service; end
end
class Steep::Services::StatsCalculator::SuccessStats < Struct
  def as_json; end
  def error_calls_count; end
  def error_calls_count=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def target; end
  def target=(_); end
  def typed_calls_count; end
  def typed_calls_count=(_); end
  def untyped_calls_count; end
  def untyped_calls_count=(_); end
end
class Steep::Services::StatsCalculator::ErrorStats < Struct
  def as_json; end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def target; end
  def target=(_); end
end
class Steep::Services::FileLoader
  def base_dir; end
  def each_path_in_patterns(pattern, commandline_patterns = nil); end
  def initialize(base_dir:); end
  def load_changes(pattern, command_line_patterns = nil, changes:); end
end
class Steep::Services::GotoService
  def constant_definition_in_rbs(name, locations:); end
  def constant_definition_in_ruby(name, locations:); end
  def definition(path:, line:, column:); end
  def implementation(path:, line:, column:); end
  def initialize(type_check:); end
  def method_locations(name, in_ruby:, in_rbs:, locations:); end
  def project; end
  def query_at(path:, line:, column:); end
  def test_ast_location(loc, line:, column:); end
  def type_check; end
  def type_check_path(target:, path:, content:, line:, column:); end
  def type_name_locations(name, locations: nil); end
  include Steep::ModuleHelper
end
module Steep::Services::GotoService::SourceHelper
  def from_rbs?; end
  def from_ruby?; end
end
class Steep::Services::GotoService::ConstantQuery < Struct
  def from; end
  def from=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  include Steep::Services::GotoService::SourceHelper
end
class Steep::Services::GotoService::MethodQuery < Struct
  def from; end
  def from=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  include Steep::Services::GotoService::SourceHelper
end
class Steep::Services::GotoService::TypeNameQuery < Struct
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Project
  def absolute_path(path); end
  def base_dir; end
  def initialize(steepfile_path:); end
  def relative_path(path); end
  def steepfile_path; end
  def target_for_source_path(path); end
  def targets; end
  def targets_for_path(path); end
end
class Steep::Project::Pattern
  def =~(path); end
  def ext; end
  def ignore?(path); end
  def ignore_prefixes; end
  def ignores; end
  def initialize(patterns:, ext:, ignores: nil); end
  def match?(path); end
  def patterns; end
  def prefixes; end
  def test_string(path, patterns, prefixes); end
end
class Steep::Project::Options
  def allow_fallback_any; end
  def allow_fallback_any=(arg0); end
  def allow_missing_definitions; end
  def allow_missing_definitions=(arg0); end
  def allow_unknown_constant_assignment; end
  def allow_unknown_constant_assignment=(arg0); end
  def allow_unknown_method_calls; end
  def allow_unknown_method_calls=(arg0); end
  def apply_default_typing_options!; end
  def apply_lenient_typing_options!; end
  def apply_strict_typing_options!; end
  def error_to_report?(error); end
  def initialize; end
  def libraries; end
  def merge!(hash); end
  def repository_paths; end
  def vendor_path; end
  def vendor_path=(arg0); end
end
class Steep::Project::Target
  def initialize(name:, options:, source_pattern:, signature_pattern:); end
  def name; end
  def new_env_loader(project:); end
  def options; end
  def possible_signature_file?(path); end
  def possible_source_file?(path); end
  def self.construct_env_loader(options:, project:); end
  def signature_pattern; end
  def source_pattern; end
end
class Steep::Project::DSL
  def initialize(project:); end
  def project; end
  def self.parse(project, code, filename: nil); end
  def self.register_template(name, target); end
  def self.templates; end
  def target(name, template: nil, &block); end
end
class Steep::Project::DSL::TargetDSL
  def check(*args); end
  def ignore(*args); end
  def ignored_sources; end
  def initialize(name, sources: nil, libraries: nil, signatures: nil, ignored_sources: nil, repo_paths: nil); end
  def initialize_copy(other); end
  def libraries; end
  def library(*args); end
  def name; end
  def no_builtin!(value = nil); end
  def repo_path(*paths); end
  def repo_paths; end
  def signature(*args); end
  def signatures; end
  def sources; end
  def strictness_level; end
  def typing_option_hash; end
  def typing_options(level = nil, **hash); end
  def update(name: nil, sources: nil, libraries: nil, ignored_sources: nil, signatures: nil); end
  def vendor(dir = nil, stdlib: nil, gems: nil); end
  def vendor_dir; end
end
class Steep::Expectations
  def diagnostics; end
  def initialize; end
  def self.empty; end
  def self.hash_to_lsp(hash); end
  def self.load(path:, content:); end
  def self.lsp_to_hash(lsp); end
  def self.sort_key(hash); end
  def test(path:, diagnostics:); end
  def to_yaml; end
end
class Steep::Expectations::TestResult
  def actual; end
  def each_diagnostics; end
  def empty?; end
  def expectation; end
  def expected_diagnostics; end
  def initialize(path:, expectation:, actual:); end
  def missing_diagnostics; end
  def path; end
  def satisfied?; end
  def unexpected_diagnostics; end
end
module Steep::Drivers
end
module Steep::Drivers::Utils
end
module Steep::Drivers::Utils::DriverHelper
  def load_config(path: nil); end
  def request_id; end
  def shutdown_exit(writer:, reader:); end
  def steepfile; end
  def steepfile=(arg0); end
  def type_check(project); end
  def wait_for_message(reader:, unknown_messages: nil, &block); end
  def wait_for_response_id(reader:, id:, unknown_responses: nil); end
end
module Steep::Drivers::Utils::JobsCount
  def jobs_count; end
  def jobs_count=(arg0); end
end
class Steep::Drivers::Check
  def command_line_patterns; end
  def initialize(stdout:, stderr:); end
  def print_expectations(project:, all_files:, expectations_path:, notifications:); end
  def print_result(project:, notifications:); end
  def run; end
  def save_expectations(project:, all_files:, expectations_path:, notifications:); end
  def save_expectations_path; end
  def save_expectations_path=(arg0); end
  def stderr; end
  def stdout; end
  def with_expectations_path; end
  def with_expectations_path=(arg0); end
  include Steep::Drivers::Utils::DriverHelper
  include Steep::Drivers::Utils::JobsCount
end
class Steep::Drivers::Stats
  def command_line_patterns; end
  def format; end
  def format=(arg0); end
  def initialize(stdout:, stderr:); end
  def run; end
  def stderr; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
  include Steep::Drivers::Utils::JobsCount
end
class Steep::Drivers::Stats::CSVPrinter
  def initialize(io:); end
  def io; end
  def print(stats_result); end
end
class Steep::Drivers::Stats::TablePrinter
  def initialize(io:); end
  def io; end
  def print(stats_result); end
end
class Steep::Drivers::Validate
  def initialize(stdout:, stderr:); end
  def run; end
  def stderr; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Annotations
  def command_line_patterns; end
  def initialize(stdout:, stderr:); end
  def run; end
  def stderr; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Watch
  def dirs; end
  def initialize(stdout:, stderr:); end
  def queue; end
  def run; end
  def stderr; end
  def stdout; end
  def watching?(changed_path, files:, dirs:); end
  include Steep::Drivers::Utils::DriverHelper
  include Steep::Drivers::Utils::JobsCount
end
class Steep::Drivers::Langserver
  def initialize(stdout:, stderr:, stdin:); end
  def latest_update_version; end
  def project; end
  def reader; end
  def run; end
  def stderr; end
  def stdin; end
  def stdout; end
  def type_check_queue; end
  def type_check_thread; end
  def write_mutex; end
  def writer; end
  include Steep::Drivers::Utils::DriverHelper
  include Steep::Drivers::Utils::JobsCount
end
class Steep::Drivers::Langserver::TypeCheckRequest < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def version; end
  def version=(_); end
end
class Steep::Drivers::TracePrinter
  def initialize(io); end
  def io; end
  def print(trace, level: nil); end
end
class Steep::Drivers::PrintProject
  def initialize(stdout:, stderr:); end
  def run; end
  def stderr; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Init
  def force_write; end
  def force_write=(arg0); end
  def initialize(stdout:, stderr:); end
  def run; end
  def stderr; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Vendor
  def clean_before; end
  def clean_before=(arg0); end
  def initialize(stdout:, stderr:, stdin:); end
  def run; end
  def stderr; end
  def stdin; end
  def stdout; end
  def vendor_dir; end
  def vendor_dir=(arg0); end
end
class Steep::Drivers::Worker
  def commandline_args; end
  def commandline_args=(arg0); end
  def delay_shutdown; end
  def delay_shutdown=(arg0); end
  def index; end
  def index=(arg0); end
  def initialize(stdout:, stderr:, stdin:); end
  def max_index; end
  def max_index=(arg0); end
  def run; end
  def stderr; end
  def stdin; end
  def stdout; end
  def steepfile_path; end
  def steepfile_path=(arg0); end
  def worker_name; end
  def worker_name=(arg0); end
  def worker_type; end
  def worker_type=(arg0); end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::DiagnosticPrinter
  def buffer; end
  def color_severity(string, severity:); end
  def initialize(stdout:, buffer:); end
  def location(diagnostic); end
  def path; end
  def print(diagnostic, prefix: nil, source: nil); end
  def print_source_line(diagnostic, prefix: nil); end
  def severity_message(severity); end
  def stdout; end
end
class Steep::Sampler
  def average; end
  def count; end
  def initialize; end
  def percentile(p); end
  def sample(message); end
  def slowests(num); end
  def total; end
end
