# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: ignore
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/activesupport/all/activesupport.rbi
#
# activesupport-6.1.3.2

class Hash
  def blank?; end
  def compact_blank!; end
  def compact_blank; end
  def deep_merge!(other_hash, &block); end
  def deep_merge(other_hash, &block); end
  def except!(*keys); end
  def except(*keys); end
  def extract!(*keys); end
  def extractable_options?; end
  def slice!(*keys); end
end
module ActiveSupport
  def self.eager_load!; end
  def self.gem_version; end
  def self.test_order; end
  def self.test_order=(val); end
  def self.to_time_preserves_timezone; end
  def self.to_time_preserves_timezone=(value); end
  def self.utc_to_local_returns_utc_offset_times; end
  def self.utc_to_local_returns_utc_offset_times=(value); end
  def self.version; end
  def test_order; end
  def test_order=(val); end
  extend ActiveSupport::Autoload
  extend ActiveSupport::LazyLoadHooks
end
module ActiveSupport::LazyLoadHooks
  def execute_hook(name, base, options, block); end
  def on_load(name, options = nil, &block); end
  def run_load_hooks(name, base = nil); end
  def self.extended(base); end
  def with_execution_control(name, block, once); end
end
module ActiveSupport::Inflector
  def apply_inflections(word, rules, locale = nil); end
  def camelize(term, uppercase_first_letter = nil); end
  def classify(table_name); end
  def const_regexp(camel_cased_word); end
  def constantize(camel_cased_word); end
  def dasherize(underscored_word); end
  def deconstantize(path); end
  def demodulize(path); end
  def foreign_key(class_name, separate_class_name_and_id_with_underscore = nil); end
  def humanize(lower_case_and_underscored_word, capitalize: nil, keep_id_suffix: nil); end
  def inflections(locale = nil); end
  def ordinal(number); end
  def ordinalize(number); end
  def parameterize(string, separator: nil, preserve_case: nil, locale: nil); end
  def pluralize(word, locale = nil); end
  def safe_constantize(camel_cased_word); end
  def singularize(word, locale = nil); end
  def tableize(class_name); end
  def titleize(word, keep_id_suffix: nil); end
  def transliterate(string, replacement = nil, locale: nil); end
  def underscore(camel_cased_word); end
  def upcase_first(string); end
  extend ActiveSupport::Inflector
  extend ActiveSupport::Inflector
end
class ActiveSupport::Inflector::Inflections
  def acronym(word); end
  def acronyms; end
  def acronyms_camelize_regex; end
  def acronyms_underscore_regex; end
  def clear(scope = nil); end
  def define_acronym_regex_patterns; end
  def human(rule, replacement); end
  def humans; end
  def initialize; end
  def initialize_dup(orig); end
  def irregular(singular, plural); end
  def plural(rule, replacement); end
  def plurals; end
  def self.instance(locale = nil); end
  def singular(rule, replacement); end
  def singulars; end
  def uncountable(*words); end
  def uncountables; end
end
class ActiveSupport::Inflector::Inflections::Uncountables < Array
  def <<(*word); end
  def add(words); end
  def delete(entry); end
  def initialize; end
  def to_regex(string); end
  def uncountable?(str); end
end
class Object < BasicObject
  def blank?; end
  def presence; end
  def present?; end
  include ActiveSupport::Tryable
end
class NilClass
  def blank?; end
  def try!(_method_name = nil, *arg1); end
  def try(_method_name = nil, *arg1); end
end
class FalseClass
  def blank?; end
end
class TrueClass
  def blank?; end
end
class Array
  def blank?; end
  def compact_blank!; end
  def extract_options!; end
end
class String
  def blank?; end
  def camelcase(first_letter = nil); end
  def camelize(first_letter = nil); end
  def classify; end
  def constantize; end
  def dasherize; end
  def deconstantize; end
  def demodulize; end
  def foreign_key(separate_class_name_and_id_with_underscore = nil); end
  def humanize(capitalize: nil, keep_id_suffix: nil); end
  def is_utf8?; end
  def mb_chars; end
  def parameterize(separator: nil, preserve_case: nil, locale: nil); end
  def pluralize(count = nil, locale = nil); end
  def remove!(*patterns); end
  def remove(*patterns); end
  def safe_constantize; end
  def singularize(locale = nil); end
  def squish!; end
  def squish; end
  def tableize; end
  def titlecase(keep_id_suffix: nil); end
  def titleize(keep_id_suffix: nil); end
  def truncate(truncate_at, options = nil); end
  def truncate_bytes(truncate_at, omission: nil); end
  def truncate_words(words_count, options = nil); end
  def underscore; end
  def upcase_first; end
end
class Numeric
  def blank?; end
end
class Time
  def blank?; end
end
module ActiveSupport::Autoload
  def autoload(const_name, path = nil); end
  def autoload_at(path); end
  def autoload_under(path); end
  def autoloads; end
  def eager_autoload; end
  def eager_load!; end
  def self.extended(base); end
end
module ActiveSupport::VERSION
end
module ActiveSupport::Concern
  def append_features(base); end
  def class_methods(&class_methods_module_definition); end
  def included(base = nil, &block); end
  def prepend_features(base); end
  def prepended(base = nil, &block); end
  def self.extended(base); end
end
class ActiveSupport::Concern::MultipleIncludedBlocks < StandardError
  def initialize; end
end
class ActiveSupport::Concern::MultiplePrependBlocks < StandardError
  def initialize; end
end
class Module
  def cattr_accessor(*syms, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil, &blk); end
  def cattr_reader(*syms, instance_reader: nil, instance_accessor: nil, default: nil, location: nil); end
  def cattr_writer(*syms, instance_writer: nil, instance_accessor: nil, default: nil, location: nil); end
  def delegate(*methods, to: nil, prefix: nil, allow_nil: nil, private: nil); end
  def delegate_missing_to(target, allow_nil: nil); end
  def mattr_accessor(*syms, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil, &blk); end
  def mattr_reader(*syms, instance_reader: nil, instance_accessor: nil, default: nil, location: nil); end
  def mattr_writer(*syms, instance_writer: nil, instance_accessor: nil, default: nil, location: nil); end
  def method_visibility(method); end
  def redefine_method(method, &block); end
  def redefine_singleton_method(method, &block); end
  def silence_redefinition_of_method(method); end
end
module ActiveSupport::LoggerThreadSafeLevel
  def add(severity, message = nil, progname = nil, &block); end
  def debug?; end
  def error?; end
  def fatal?; end
  def info?; end
  def level; end
  def local_level; end
  def local_level=(level); end
  def local_log_id; end
  def log_at(level); end
  def unknown?; end
  def warn?; end
  extend ActiveSupport::Concern
end
module ActiveSupport::LoggerSilence
  def silence(severity = nil); end
  extend ActiveSupport::Concern
end
class ActiveSupport::Logger < Logger
  def initialize(*args, **kwargs); end
  def self.broadcast(logger); end
  def self.local_levels; end
  def self.local_levels=(val); end
  def self.logger_outputs_to?(logger, *sources); end
  def self.silencer; end
  def self.silencer=(val); end
  def silencer; end
  def silencer=(val); end
  include ActiveSupport::LoggerSilence
  include ActiveSupport::LoggerThreadSafeLevel
end
class ActiveSupport::Logger::SimpleFormatter < Logger::Formatter
  def call(severity, timestamp, progname, msg); end
end
module DateAndTime
end
module DateAndTime::Compatibility
  def preserve_timezone; end
  def self.preserve_timezone; end
  def self.preserve_timezone=(val); end
  def self.utc_to_local_returns_utc_offset_times; end
  def self.utc_to_local_returns_utc_offset_times=(val); end
  def utc_to_local_returns_utc_offset_times; end
end
module ActiveSupport::ActionableError
  def self.actions(error); end
  def self.dispatch(error, name); end
  extend ActiveSupport::Concern
end
class ActiveSupport::ActionableError::NonActionable < StandardError
end
module ActiveSupport::ActionableError::ClassMethods
  def action(name, &block); end
end
module ActiveSupport::DescendantsTracker
  def descendants; end
  def direct_descendants; end
  def inherited(base); end
  def self.accumulate_descendants(klass, acc); end
  def self.clear; end
  def self.descendants(klass); end
  def self.direct_descendants(klass); end
  def self.store_inherited(klass, descendant); end
  def self.subclasses(klass); end
  def subclasses; end
end
class ActiveSupport::DescendantsTracker::DescendantsArray
  def <<(klass); end
  def cleanup!; end
  def each; end
  def initialize; end
  def initialize_copy(orig); end
  def refs_size; end
  def reject!; end
  include Enumerable
end
class Class < Module
  def class_attribute(*attrs, instance_accessor: nil, instance_reader: nil, instance_writer: nil, instance_predicate: nil, default: nil); end
end
module ActiveSupport::Callbacks
  def halted_callback_hook(filter, name); end
  def run_callbacks(kind); end
  extend ActiveSupport::Concern
end
module ActiveSupport::Callbacks::Conditionals
end
class ActiveSupport::Callbacks::Conditionals::Value
  def call(target, value); end
  def initialize(&block); end
end
module ActiveSupport::Callbacks::Filters
end
class ActiveSupport::Callbacks::Filters::Environment < Struct
  def halted; end
  def halted=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def target; end
  def target=(_); end
  def value; end
  def value=(_); end
end
class ActiveSupport::Callbacks::Filters::Before
  def self.build(callback_sequence, user_callback, user_conditions, chain_config, filter, name); end
  def self.halting(callback_sequence, user_callback, halted_lambda, filter, name); end
  def self.halting_and_conditional(callback_sequence, user_callback, user_conditions, halted_lambda, filter, name); end
end
class ActiveSupport::Callbacks::Filters::After
  def self.build(callback_sequence, user_callback, user_conditions, chain_config); end
  def self.conditional(callback_sequence, user_callback, user_conditions); end
  def self.halting(callback_sequence, user_callback); end
  def self.halting_and_conditional(callback_sequence, user_callback, user_conditions); end
  def self.simple(callback_sequence, user_callback); end
end
class ActiveSupport::Callbacks::Callback
  def apply(callback_sequence); end
  def chain_config; end
  def check_conditionals(conditionals); end
  def compute_identifier(filter); end
  def conditions_lambdas; end
  def current_scopes; end
  def duplicates?(other); end
  def filter; end
  def initialize(name, filter, kind, options, chain_config); end
  def kind; end
  def kind=(arg0); end
  def matches?(_kind, _filter); end
  def merge_conditional_options(chain, if_option:, unless_option:); end
  def name; end
  def name=(arg0); end
  def raw_filter; end
  def self.build(chain, filter, kind, options); end
end
class ActiveSupport::Callbacks::CallTemplate
  def expand(target, value, block); end
  def initialize(target, method, arguments, block); end
  def inverted_lambda; end
  def make_lambda; end
  def self.build(filter, callback); end
end
class ActiveSupport::Callbacks::CallbackSequence
  def after(&after); end
  def around(call_template, user_conditions); end
  def before(&before); end
  def expand_call_template(arg, block); end
  def final?; end
  def initialize(nested = nil, call_template = nil, user_conditions = nil); end
  def invoke_after(arg); end
  def invoke_before(arg); end
  def nested; end
  def skip?(arg); end
end
class ActiveSupport::Callbacks::CallbackChain
  def append(*callbacks); end
  def append_one(callback); end
  def chain; end
  def clear; end
  def compile; end
  def config; end
  def default_terminator; end
  def delete(o); end
  def each(&block); end
  def empty?; end
  def index(o); end
  def initialize(name, config); end
  def initialize_copy(other); end
  def insert(index, o); end
  def name; end
  def prepend(*callbacks); end
  def prepend_one(callback); end
  def remove_duplicates(callback); end
  include Enumerable
end
module ActiveSupport::Callbacks::ClassMethods
  def __update_callbacks(name); end
  def define_callbacks(*names); end
  def get_callbacks(name); end
  def normalize_callback_params(filters, block); end
  def reset_callbacks(name); end
  def set_callback(name, *filter_list, &block); end
  def set_callbacks(name, callbacks); end
  def skip_callback(name, *filter_list, &block); end
end
module Enumerable
  def _original_sum_with_required_identity(*arg0); end
  def compact_blank; end
  def exclude?(object); end
  def excluding(*elements); end
  def including(*elements); end
  def index_by; end
  def index_with(default = nil); end
  def many?; end
  def pick(*keys); end
  def pluck(*keys); end
  def without(*elements); end
end
class Range
  def sum(identity = nil); end
end
class ActiveSupport::CurrentAttributes
  def __callbacks; end
  def __callbacks?; end
  def _reset_callbacks; end
  def _run_reset_callbacks(&block); end
  def self.__callbacks; end
  def self.__callbacks=(value); end
  def self.__callbacks?; end
  def self._reset_callbacks; end
  def self._reset_callbacks=(value); end
  def self.after_reset(&block); end
  def self.attribute(*names); end
  def self.before_reset(&block); end
  def self.instance; end
  def self.resets(&block); end
  extend ActiveSupport::Callbacks::ClassMethods
  extend ActiveSupport::DescendantsTracker
  include ActiveSupport::Callbacks
end
module ActiveSupport::Tryable
  def try!(method_name = nil, *args, &b); end
  def try(method_name = nil, *args, &b); end
end
class Delegator < BasicObject
  include ActiveSupport::Tryable
end
module ActiveSupport::Multibyte
  def self.proxy_class; end
  def self.proxy_class=(klass); end
end
class Module::DelegationError < NoMethodError
end
module ActiveSupport::TaggedLogging
  def clear_tags!(**, &&); end
  def flush; end
  def pop_tags(**, &&); end
  def push_tags(**, &&); end
  def self.new(logger); end
  def tagged(*tags); end
end
module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end
  def clear_tags!; end
  def current_tags; end
  def pop_tags(size = nil); end
  def push_tags(*tags); end
  def tagged(*tags); end
  def tags_text; end
end
module ActiveSupport::TaggedLogging::LocalTagStorage
  def current_tags; end
  def current_tags=(arg0); end
  def self.extended(base); end
end
